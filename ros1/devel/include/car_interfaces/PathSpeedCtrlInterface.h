// Generated by gencpp from file car_interfaces/PathSpeedCtrlInterface.msg
// DO NOT EDIT!


#ifndef CAR_INTERFACES_MESSAGE_PATHSPEEDCTRLINTERFACE_H
#define CAR_INTERFACES_MESSAGE_PATHSPEEDCTRLINTERFACE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace car_interfaces
{
template <class ContainerAllocator>
struct PathSpeedCtrlInterface_
{
  typedef PathSpeedCtrlInterface_<ContainerAllocator> Type;

  PathSpeedCtrlInterface_()
    : timestamp(0.0)
    , Target_velocity(0.0)
    , Target_steering_angle(0.0)
    , Target_gear(0)
    , Target_primary_gear(0)
    , Target_EngineSpeedLevel(0)
    , Target_speedlever_percentage(0.0)
    , Target_Torque_Nm(0.0)
    , Target_braking_percentage(0)
    , NearestPoint_Car2Path()
    , Cotton_Bin_Ctrl(0)
    , CTE(0.0)
    , dHead(0.0)
    , brake_enable(0.0)
    , value_brake(0.0)
    , flag()
    , UpDown(0)
    , raw_control(0.0)
    , kappa(0.0)
    , x_trajectory(0.0)
    , y_trajectory(0.0)
    , gear(0)
    , action(0)
    , FY_Position(0.0)
    , FY(0)
    , IPC_En(0)
    , UpDown_Position(0.0)
    , flag_camera(0)  {
    }
  PathSpeedCtrlInterface_(const ContainerAllocator& _alloc)
    : timestamp(0.0)
    , Target_velocity(0.0)
    , Target_steering_angle(0.0)
    , Target_gear(0)
    , Target_primary_gear(0)
    , Target_EngineSpeedLevel(0)
    , Target_speedlever_percentage(0.0)
    , Target_Torque_Nm(0.0)
    , Target_braking_percentage(0)
    , NearestPoint_Car2Path(_alloc)
    , Cotton_Bin_Ctrl(0)
    , CTE(0.0)
    , dHead(0.0)
    , brake_enable(0.0)
    , value_brake(0.0)
    , flag(_alloc)
    , UpDown(0)
    , raw_control(0.0)
    , kappa(0.0)
    , x_trajectory(0.0)
    , y_trajectory(0.0)
    , gear(0)
    , action(0)
    , FY_Position(0.0)
    , FY(0)
    , IPC_En(0)
    , UpDown_Position(0.0)
    , flag_camera(0)  {
  (void)_alloc;
    }



   typedef double _timestamp_type;
  _timestamp_type timestamp;

   typedef float _Target_velocity_type;
  _Target_velocity_type Target_velocity;

   typedef float _Target_steering_angle_type;
  _Target_steering_angle_type Target_steering_angle;

   typedef uint8_t _Target_gear_type;
  _Target_gear_type Target_gear;

   typedef uint8_t _Target_primary_gear_type;
  _Target_primary_gear_type Target_primary_gear;

   typedef uint8_t _Target_EngineSpeedLevel_type;
  _Target_EngineSpeedLevel_type Target_EngineSpeedLevel;

   typedef float _Target_speedlever_percentage_type;
  _Target_speedlever_percentage_type Target_speedlever_percentage;

   typedef float _Target_Torque_Nm_type;
  _Target_Torque_Nm_type Target_Torque_Nm;

   typedef uint8_t _Target_braking_percentage_type;
  _Target_braking_percentage_type Target_braking_percentage;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _NearestPoint_Car2Path_type;
  _NearestPoint_Car2Path_type NearestPoint_Car2Path;

   typedef int8_t _Cotton_Bin_Ctrl_type;
  _Cotton_Bin_Ctrl_type Cotton_Bin_Ctrl;

   typedef float _CTE_type;
  _CTE_type CTE;

   typedef float _dHead_type;
  _dHead_type dHead;

   typedef float _brake_enable_type;
  _brake_enable_type brake_enable;

   typedef float _value_brake_type;
  _value_brake_type value_brake;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _flag_type;
  _flag_type flag;

   typedef uint8_t _UpDown_type;
  _UpDown_type UpDown;

   typedef float _raw_control_type;
  _raw_control_type raw_control;

   typedef float _kappa_type;
  _kappa_type kappa;

   typedef double _x_trajectory_type;
  _x_trajectory_type x_trajectory;

   typedef double _y_trajectory_type;
  _y_trajectory_type y_trajectory;

   typedef int8_t _gear_type;
  _gear_type gear;

   typedef int8_t _action_type;
  _action_type action;

   typedef double _FY_Position_type;
  _FY_Position_type FY_Position;

   typedef int8_t _FY_type;
  _FY_type FY;

   typedef int8_t _IPC_En_type;
  _IPC_En_type IPC_En;

   typedef float _UpDown_Position_type;
  _UpDown_Position_type UpDown_Position;

   typedef int8_t _flag_camera_type;
  _flag_camera_type flag_camera;





  typedef boost::shared_ptr< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> const> ConstPtr;

}; // struct PathSpeedCtrlInterface_

typedef ::car_interfaces::PathSpeedCtrlInterface_<std::allocator<void> > PathSpeedCtrlInterface;

typedef boost::shared_ptr< ::car_interfaces::PathSpeedCtrlInterface > PathSpeedCtrlInterfacePtr;
typedef boost::shared_ptr< ::car_interfaces::PathSpeedCtrlInterface const> PathSpeedCtrlInterfaceConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator1> & lhs, const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.Target_velocity == rhs.Target_velocity &&
    lhs.Target_steering_angle == rhs.Target_steering_angle &&
    lhs.Target_gear == rhs.Target_gear &&
    lhs.Target_primary_gear == rhs.Target_primary_gear &&
    lhs.Target_EngineSpeedLevel == rhs.Target_EngineSpeedLevel &&
    lhs.Target_speedlever_percentage == rhs.Target_speedlever_percentage &&
    lhs.Target_Torque_Nm == rhs.Target_Torque_Nm &&
    lhs.Target_braking_percentage == rhs.Target_braking_percentage &&
    lhs.NearestPoint_Car2Path == rhs.NearestPoint_Car2Path &&
    lhs.Cotton_Bin_Ctrl == rhs.Cotton_Bin_Ctrl &&
    lhs.CTE == rhs.CTE &&
    lhs.dHead == rhs.dHead &&
    lhs.brake_enable == rhs.brake_enable &&
    lhs.value_brake == rhs.value_brake &&
    lhs.flag == rhs.flag &&
    lhs.UpDown == rhs.UpDown &&
    lhs.raw_control == rhs.raw_control &&
    lhs.kappa == rhs.kappa &&
    lhs.x_trajectory == rhs.x_trajectory &&
    lhs.y_trajectory == rhs.y_trajectory &&
    lhs.gear == rhs.gear &&
    lhs.action == rhs.action &&
    lhs.FY_Position == rhs.FY_Position &&
    lhs.FY == rhs.FY &&
    lhs.IPC_En == rhs.IPC_En &&
    lhs.UpDown_Position == rhs.UpDown_Position &&
    lhs.flag_camera == rhs.flag_camera;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator1> & lhs, const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace car_interfaces

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "02bb193daca16799d8ba2ebb4fa7c792";
  }

  static const char* value(const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x02bb193daca16799ULL;
  static const uint64_t static_value2 = 0xd8ba2ebb4fa7c792ULL;
};

template<class ContainerAllocator>
struct DataType< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "car_interfaces/PathSpeedCtrlInterface";
  }

  static const char* value(const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64  timestamp         # 数据帧时间戳\n"
"float32  Target_velocity    # 车辆速度m/s\n"
"float32  Target_steering_angle    # 车辆转角，方向盘转角 \n"
"uint8  Target_gear   # 01：驻车；02：空挡（N）；03：前进（D）；04：后退（R）；05：无效；\n"
"uint8  Target_primary_gear   # 01：低速，02：中速；03：高速；\n"
"uint8  Target_EngineSpeedLevel   # 01：低速；02：中速；03：高速；\n"
"float32  Target_speedlever_percentage   #车速手柄（采棉机）开度（-1000-1000）   对应【-100%, 100%】，负数为后退，正数为前进。\n"
"float32  Target_Torque_Nm   #目标驱动扭矩（单位：Nm，没有则给0）。\n"
"uint8  Target_braking_percentage   #制动行程请求，最大行程点125，最小行程点为0，单位为个（当前将行程分成125个点）\n"
"float32[] NearestPoint_Car2Path  # 反馈当前车辆位置距离规划的局部路径的最近点，包括：\n"
"# float   longitude        # 途径点经度（东向坐标，单位为：m）\n"
"# float   latitude         # 途径点纬度（北向坐标，单位为：m）\n"
"# float   speed         # 途径点速度（单位：m/s）\n"
"\n"
"\n"
"# add cyun 8.1\n"
"int8 Cotton_Bin_Ctrl #棉线动作使能\n"
"\n"
"\n"
"# add cyun 8.21\n"
"float32 CTE\n"
"float32 dHead\n"
"\n"
"# add cyun 8.30\n"
"float32 brake_enable  #刹车使能\n"
"float32 value_brake   #刹车量\n"
"\n"
"# add cyun 8.31\n"
"float32[]  flag # 标志位，控制给线控，表明发送成功\n"
"\n"
"uint8 UpDown\n"
"float32 raw_control # \n"
"\n"
"\n"
"float32 kappa #采棉时转弯，提采头的判断\n"
"\n"
"float64 x_trajectory\n"
"float64 y_trajectory\n"
"\n"
"int8 gear # 档位 0 1-倒退 2 3-前进\n"
"int8 action # 0-关 1-取货 2-卸货\n"
"float64 FY_Position\n"
"int8 FY\n"
"\n"
"\n"
"int8 IPC_En\n"
"float32 UpDown_Position\n"
"\n"
"int8 flag_camera\n"
;
  }

  static const char* value(const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.Target_velocity);
      stream.next(m.Target_steering_angle);
      stream.next(m.Target_gear);
      stream.next(m.Target_primary_gear);
      stream.next(m.Target_EngineSpeedLevel);
      stream.next(m.Target_speedlever_percentage);
      stream.next(m.Target_Torque_Nm);
      stream.next(m.Target_braking_percentage);
      stream.next(m.NearestPoint_Car2Path);
      stream.next(m.Cotton_Bin_Ctrl);
      stream.next(m.CTE);
      stream.next(m.dHead);
      stream.next(m.brake_enable);
      stream.next(m.value_brake);
      stream.next(m.flag);
      stream.next(m.UpDown);
      stream.next(m.raw_control);
      stream.next(m.kappa);
      stream.next(m.x_trajectory);
      stream.next(m.y_trajectory);
      stream.next(m.gear);
      stream.next(m.action);
      stream.next(m.FY_Position);
      stream.next(m.FY);
      stream.next(m.IPC_En);
      stream.next(m.UpDown_Position);
      stream.next(m.flag_camera);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PathSpeedCtrlInterface_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::car_interfaces::PathSpeedCtrlInterface_<ContainerAllocator>& v)
  {
    if (false || !indent.empty())
      s << std::endl;
    s << indent << "timestamp: ";
    Printer<double>::stream(s, indent + "  ", v.timestamp);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Target_velocity);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_steering_angle: ";
    Printer<float>::stream(s, indent + "  ", v.Target_steering_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Target_gear);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_primary_gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Target_primary_gear);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_EngineSpeedLevel: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Target_EngineSpeedLevel);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_speedlever_percentage: ";
    Printer<float>::stream(s, indent + "  ", v.Target_speedlever_percentage);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_Torque_Nm: ";
    Printer<float>::stream(s, indent + "  ", v.Target_Torque_Nm);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Target_braking_percentage: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Target_braking_percentage);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "NearestPoint_Car2Path: ";
    if (v.NearestPoint_Car2Path.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.NearestPoint_Car2Path.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<float>::stream(s, true ? std::string() : indent + "    ", v.NearestPoint_Car2Path[i]);
    }
    if (v.NearestPoint_Car2Path.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Cotton_Bin_Ctrl: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Cotton_Bin_Ctrl);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "CTE: ";
    Printer<float>::stream(s, indent + "  ", v.CTE);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "dHead: ";
    Printer<float>::stream(s, indent + "  ", v.dHead);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "brake_enable: ";
    Printer<float>::stream(s, indent + "  ", v.brake_enable);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "value_brake: ";
    Printer<float>::stream(s, indent + "  ", v.value_brake);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "flag: ";
    if (v.flag.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.flag.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<float>::stream(s, true ? std::string() : indent + "    ", v.flag[i]);
    }
    if (v.flag.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "UpDown: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.UpDown);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "raw_control: ";
    Printer<float>::stream(s, indent + "  ", v.raw_control);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "kappa: ";
    Printer<float>::stream(s, indent + "  ", v.kappa);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "x_trajectory: ";
    Printer<double>::stream(s, indent + "  ", v.x_trajectory);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "y_trajectory: ";
    Printer<double>::stream(s, indent + "  ", v.y_trajectory);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "gear: ";
    Printer<int8_t>::stream(s, indent + "  ", v.gear);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "action: ";
    Printer<int8_t>::stream(s, indent + "  ", v.action);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "FY_Position: ";
    Printer<double>::stream(s, indent + "  ", v.FY_Position);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "FY: ";
    Printer<int8_t>::stream(s, indent + "  ", v.FY);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "IPC_En: ";
    Printer<int8_t>::stream(s, indent + "  ", v.IPC_En);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "UpDown_Position: ";
    Printer<float>::stream(s, indent + "  ", v.UpDown_Position);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "flag_camera: ";
    Printer<int8_t>::stream(s, indent + "  ", v.flag_camera);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CAR_INTERFACES_MESSAGE_PATHSPEEDCTRLINTERFACE_H
